---
title: "CONSTANd vs median sweeping for Data-driven analysis of isobarically labeled proteomic data."
author: "Joris Van Houtven, Piotr Prostko"
date: '`r format(Sys.time(), "%B %d, %Y,%H:%M")`'
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
    theme: flatly
    code_folding: "hide"
editor_options: 
  chunk_output_type: console
params:
  input_data_p: 'input_data_msstatstmt.rds'
  suffix_p: 'msstatstmt'
  load_outputdata_p: FALSE
  subsample_p: 0
---
  
```{r, setup, include=FALSE}
# default knitr options for all chunks
knitr::opts_chunk$set(
  message=FALSE,
  warning=FALSE,
  fig.width=12,
  fig.height=7
)
```

```{r}
library(ggplot2)
library(stringi)
library(gridExtra)
library(dendextend)
library(kableExtra)
library(limma)
library(psych)
library(tidyverse)
library(CONSTANd)  # install from source: https://github.com/PDiracDelta/CONSTANd/
source('other_functions.R')
source('plotting_functions.R')
```

This notebook presents isobaric labeling data analysis strategy that includes data-driven normalization. 

In other notebooks in this series we have systematically varied components and observed how they affect the outcome of a DEA analysis. We have seen that median sweeping normalization works does not work well for intensities on the original scale, and that CONSTANd does not work well on log2-transformed intensities. Here we compare median sweeping on log2 scale, which we know does a good job, with CONSTANd on original intensity scale.

```{r}
data.list <- readRDS(params$input_data_p)
dat.l <- data.list$dat.l # data in long format
# which proteins were spiked in?
spiked.proteins <- dat.l %>% distinct(Protein) %>% filter(stri_detect(Protein, fixed='ups')) %>% pull %>% as.character
tmp=dat.l %>% distinct(Protein) %>% pull %>% as.character
# protein subsampling
if (params$subsample_p>0 & params$subsample_p==floor(params$subsample_p) & params$subsample_p<=length(tmp)){
  sub.prot <- tmp[sample(1:length(tmp), size=params$subsample_p)]
  if (length(spiked.proteins)>0) sub.prot <- c(sub.prot,spiked.proteins)
  dat.l <- dat.l %>% filter(Protein %in% sub.prot)
}
```

```{r}
# specify # of varying component variants and their names
variant.names <- c('median_sweeping', 'CONSTANd')
n.comp.variants <- length(variant.names)
scale.vec <- c('log', 'raw')

# get some data parameters created in the data_prep script
referenceCondition <- data.list$data.params$referenceCondition
condition.color <- data.list$data.params$condition.color
ma.onesample.num <- data.list$data.params$ma.onesample.num
ma.onesample.denom <- data.list$data.params$ma.onesample.denom
ma.allsamples.num <- data.list$data.params$ma.allsamples.num
ma.allsamples.denom <- data.list$data.params$ma.allsamples.denom
# create data frame with sample information
sample.info <- get_sample_info(dat.l, condition.color)
# get channel names
channelNames <- remove_factors(unique(sample.info$Channel))
```

# Unit scale component

```{r}
dat.unit.l <- emptyList(variant.names)
```

## median sweeping: log2 intensity

```{r}
dat.unit.l$median_sweeping <- dat.l %>% mutate(response=log2(intensity)) %>% select(-intensity)
```

## CONSTANd: original intensity
```{r}
dat.unit.l$CONSTANd <- dat.l %>% rename(response=intensity)
```

# Normalization component

CONSTANd vs median sweeping (in 2 steps)

```{r}
# switch to wide format
dat.unit.w <- lapply(dat.unit.l, function(x) {
  pivot_wider(data = x, id_cols=-one_of(c('Condition', 'BioReplicate')), names_from=Channel, values_from=response)
})
dat.norm.w <- emptyList(names(dat.unit.w))
```

## median sweeping (1)

```{r}
# subtract the spectrum median log2intensity from the observed log2intensities
dat.norm.w$median_sweeping <- dat.unit.w$median_sweeping
dat.norm.w$median_sweeping[,channelNames] <- dat.norm.w$median_sweeping[,channelNames] %>% sweep(1, apply(.[,channelNames], 1, median, na.rm=T))
dat.norm.w$median_sweeping
```

## CONSTANd

Now let's apply CONSTANd to each Run separately, and then combine the results into a semi-wide dataframe again.

```{r}
# dat.unit.l entries are in long format so all have same colnames and no channelNames
x.split <- split(dat.unit.w$CONSTANd, dat.unit.w$CONSTANd$Run)  # apply CONSTANd to each Run separately
x.split.norm  <- lapply(x.split, function(y) {
  y[,channelNames] <- CONSTANd(y[,channelNames])$normalized_data
  return(y)
})
dat.norm.w$CONSTANd <- bind_rows(x.split.norm)
dat.norm.w$CONSTANd
```

# Summarization component: Median summarization

Summarize quantification values from PSM to peptide (first step) to protein (second step).

```{r}
# normalized data
# group by (run,)protein,peptide then summarize twice (once on each level)
dat.norm.summ.w <- lapply(dat.norm.w, function(x) x %>% group_by(Run, Protein, Peptide) %>% summarise_at(.vars = channelNames, .funs = median, na.rm=T) %>% summarise_at(.vars = channelNames, .funs = median, na.rm=T) %>% ungroup() )
```

Notice that the row sums are not equal to Ncols anymore, because the median summarization
does not preserve them (but mean summarization does).

# Normalization component: median sweeping (2)

```{r}
# median sweeping: in each channel, subtract median computed across all proteins within the channel
# do the above separately for each MS run
x.split <- split(dat.norm.summ.w$median_sweeping, dat.norm.summ.w$median_sweeping$Run)
x.split.norm  <- lapply( x.split, function(y) {
  y[,channelNames] <- sweep(y[,channelNames], 2, apply(y[,channelNames], 2, median, na.rm=T) )
  return(y) } )
dat.norm.summ.w$median_sweeping <- bind_rows(x.split.norm)
```

# QC plots

```{r}
# make data completely wide (also across runs)
dat.norm.summ.w2 <- lapply( dat.norm.summ.w, function(x) x %>% pivot_wider(names_from = Run, values_from = all_of(channelNames), names_glue = "{Run}:{.value}") )
```

## Boxplots

```{r}
# use (half-)wide format
par(mfrow=c(1,2))
for (i in seq_along(variant.names)) {
  boxplot_w(dat.norm.summ.w[[variant.names[i]]], sample.info, paste('normalized', variant.names[i], sep='_'))}
```

## MA plots

MA plots of two single samples taken from condition `r ma.allsamples.num` and condition `r ma.allsamples.denom`, measured in different MS runs (samples *`r ma.onesample.num`* and *`r ma.onesample.denom`*, respectively).

```{r}
# use wide2 format
p <- emptyList(variant.names)
for (i in 1: n.comp.variants){
  p[[i]] <- maplot_ils(dat.norm.summ.w2[[i]], ma.onesample.num, ma.onesample.denom, scale.vec[i], paste('normalized', variant.names[i], sep='_'), spiked.proteins)}
grid.arrange(p[[1]], p[[2]], ncol=2)
```

MA plots of all samples from condition *`r ma.allsamples.num`* and condition *`r ma.allsamples.denom`* (quantification values averaged within condition).

```{r}
channels.num <- sample.info %>% filter(Condition==ma.allsamples.num) %>% select(Sample) %>% pull
channels.denom <- sample.info %>% filter(Condition==ma.allsamples.denom) %>% select(Sample) %>% pull
p <- emptyList(variant.names)
for (i in 1:n.comp.variants){
  p[[i]] <- maplot_ils(dat.norm.summ.w2[[i]], channels.num, channels.denom, scale=scale.vec[i], paste('normalized', variant.names[i], sep='_'), spiked.proteins)}
grid.arrange(p[[1]], p[[2]], ncol=2)
```

```{r, echo=FALSE}
dat.norm.summ.l <- lapply(dat.norm.summ.w, to_long_format, sample.info)
```

## PCA plots

### Using all proteins
```{r}
par(mfrow=c(1, 2))
for (i in 1:n.comp.variants){
  pcaplot_ils(dat.norm.summ.w2[[variant.names[i]]] %>% select(-'Protein'), info=sample.info, paste('normalized', variant.names[i], sep='_'))}
```

### Using spiked proteins only (if applicable)
```{r, eval=length(spiked.proteins)>0}
par(mfrow=c(1, 2))
for (i in 1:n.comp.variants){
  pcaplot_ils(dat.norm.summ.w2[[variant.names[i]]] %>% filter(Protein %in% spiked.proteins) %>% select(-'Protein'), info=sample.info, paste('normalized', variant.names[i], sep='_'))}
```

## HC (hierarchical clustering) plots

### Using all proteins

```{r}
par(mfrow=c(1, 2))
for (i in 1:n.comp.variants){
  dendrogram_ils(dat.norm.summ.w2[[variant.names[i]]] %>% select(-Protein), info=sample.info, paste('normalized', variant.names[i], sep='_'))}
```

## Run effect p-value plot

Below the histograms of p-values from the linear model explaining the response variable with Run as a covariate.

```{r}
dat <- list(dat.norm.summ.l$median_sweeping, dat.norm.summ.l$CONSTANd)
names(dat) <- c('median_sweeping','CONSTANd')
run_effect_plot(dat)
```

# DEA component: Moderated t-test

NOTE:
- actually, lmFit (used in moderated_ttest) was built for log2-transformed data. However, supplying untransformed intensities can also work. This just means that the effects in the linear model are also additive on the untransformed scale, whereas for log-transformed data they are multiplicative on the untransformed scale. Also, there may be a bias which occurs from biased estimates of the population means in the t-tests, as mean(X) is not equal to exp(mean(log(X))).
```{r}
design.matrix <- get_design_matrix(referenceCondition, sample.info)
dat.dea <- emptyList(names(dat.norm.summ.w2))
for (i in seq_along(dat.norm.summ.w2)) {
  this_scale <- scale.vec[match(names(dat.dea)[i], variant.names)]
  d <- column_to_rownames(as.data.frame(dat.norm.summ.w2[[variant.names[i]]]), 'Protein')
  dat.dea[[variant.names[i]]] <- moderated_ttest(dat=d, design.matrix, scale=this_scale)}
```

# Results comparison

## Confusion matrix

```{r, results='asis'}
cm <- conf_mat(dat.dea, 'q.mod', 0.05, spiked.proteins)
print_conf_mat(cm, referenceCondition)
```

## Scatter plots

```{r}
# character vectors containing logFC and p-values columns
dea.cols <- colnames(dat.dea[[1]])
logFC.cols <- dea.cols[stri_detect_fixed(dea.cols, 'logFC')]
significance.cols <- dea.cols[stri_detect_fixed(dea.cols, 'q.mod')]
n.contrasts <- length(logFC.cols)

scatterplot_ils(dat.dea, significance.cols, 'q-values', spiked.proteins, referenceCondition)
scatterplot_ils(dat.dea, logFC.cols, 'log2FC', spiked.proteins, referenceCondition)
```

## Volcano plots

```{r}
for (i in 1:n.contrasts){
  volcanoplot_ils(dat.dea, i, spiked.proteins, referenceCondition)}
```

## Violin plots

Let's see whether the spiked protein fold changes make sense
```{r, eval=length(spiked.proteins)>0}
# plot theoretical value (horizontal lines) and violin per variant
violinplot_ils(lapply(dat.dea, function(x) x[spiked.proteins, logFC.cols]), referenceCondition)
```

```{r}
# save data sets
save(dat.norm.w,
     dat.norm.summ.w
     ,dat.norm.summ.l
     ,dat.norm.summ.w2
     ,dat.dea, file=paste0('constand_vs_mediansweeping_outdata_', params$suffix_p, '.rda'))
```


# Conclusions

# Session information

```{r}
sessionInfo()
```
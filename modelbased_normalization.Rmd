---
title: "Model-based analysis of isobaric labels data. Normalization component."
author: "Piotr Prostko"
date: '`r format(Sys.time(), "%B %d, %Y,%H:%M")`'
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
    theme: flatly
    code_folding: "hide"
editor_options: 
  chunk_output_type: console
---

```{r, setup, include=FALSE}
# default knitr options for all chunks
knitr::opts_chunk$set(
  message=FALSE,
  warning=FALSE,
  fig.width=12,
  fig.height=9
)
```

```{r}
library(caret)
#library(DEP)
#library(nlme)
library(lme4)
library(lmerTest)
library(limma)
library(ggplot2)
library(stringi)
library(RColorBrewer)
library(gridExtra)
library(ggfortify)
library(dendextend)
library(psych)
library(xtable)
library(kableExtra)
library(tidyverse)
```

This notebook presents isobaric labeling data analysis strategy that includes model-based normalization [data-driven normalization]. 

We will check how varying analysis components [unit/summarization/normalization/differential abundance testing methods] changes end results of a quantitative proteomic study.

```{r}
source('other_functions.R')
source('plotting_functions.R')

# you should either make a symbolic link in this directory
data.list <- readRDS('input_data.rds')
dat.l <- data.list$dat.l # data in long format
dat.w <- data.list$dat.w # data in semi-wide format (wide only within runs)

# keep spectra with (isolation interference <=30 or NA) and no missing quantification channels
dat.l <- dat.l %>% filter(isoInterOk & noNAs)

# which spiked-in proteins are left?
spiked.proteins <- dat.l %>% distinct(Protein) %>% filter(stri_detect(Protein, fixed='ups')) %>% pull %>% as.character

# which peptides were identified in each MS run?
unique.pep=dat.l %>% 
  group_by(Run) %>%
  distinct(Peptide) %>% 
  mutate(val=1)
unique.pep <- xtabs(val~Peptide+Run, data=unique.pep)
tmp <- apply(unique.pep, 1, function(x) all(x==1))
inner.peptides <- rownames(unique.pep)[tmp]
```

```{r}
# specify # of varying component variants and their names
n.comp.variants <- 3
variant.names <- c('LMM1', 'LMM2', 'LMM3')
# pick reference channel and condition for making plots / doing DEA
referenceChannel <- '127C'
referenceCondition <- '0.5'
```

# Unit component

```{r}
dat.unit.l <- vector('list', 1)
```

## log2 transformation of reporter ion intensities

```{r}
dat.unit.l[[1]] <- dat.l %>% mutate(response=log2(Intensity)) %>% select(-Intensity)
```

# Summarization component

## no summarization

```{r}
# no summarization 
dat.summ.l <- dat.unit.l
```

# Normalization component

```{r}
dat.norm.l <- emptyList(variant.names)
dat.norm.l <- lapply(dat.norm.l, function(x) x[[1]] <- dat.summ.l[[1]])
```

## mixed model spec 1

```{r, cache=TRUE}
LMM1 <- lmer(response ~ Mixture + Mixture:TechRepMixture + Mixture:TechRepMixture:Channel + (1|Protein)  + (1|Mixture:TechRepMixture:Peptide), data=dat.summ.l[[1]])
dat.norm.l[[1]]$response <- residuals(LMM1)
```

## mixed model spec 2

```{r}
LMM2 <- lmer(response ~ Mixture + Mixture:TechRepMixture + Mixture:TechRepMixture:Channel + (1|Mixture:TechRepMixture:Protein)  + (1|Peptide), data=dat.summ.l[[1]])
dat.norm.l[[2]]$response <- residuals(LMM2)
```

## mixed model spec 3

```{r}
LMM3 <- lmer(response ~ Mixture + Mixture:TechRepMixture + Mixture:TechRepMixture:Channel + (1|Protein)  + (1|Peptide), data=dat.summ.l[[1]])
dat.norm.l[[3]]$response <- residuals(LMM3)
```

# QC plots

```{r}
# PSM data needs to be aggregated prior to PCA plots and HC plots (they require features in the intersection of all MS runs - this is not possible for PSM data). In order to be consistent, other normalization plots will be based on the aggregated data
dat.summplot.l <- lapply(dat.summ.l, function(x) aggFunc(x, 'response', 'mean')) # before normalization (you still need to aggregate the data because of 'dat.summ.l <- dat.unit.l' operation)
dat.normplot.l <- lapply(dat.norm.l, function(x) aggFunc(x, 'response', 'mean')) # after normalization

# now create data sets in wide format
# before normalization
dat.summplot.w <- lapply(dat.summplot.l, function(x) {
  dat.tmp <- pivot_wider(data=x, id_cols=Peptide, names_from=Run:Channel, values_from=response, names_sep=':') %>% column_to_rownames('Peptide')
  return(dat.tmp)
})

# after normalization
dat.normplot.w <- lapply(dat.normplot.l, function(x) {
  dat.tmp <- pivot_wider(data=x, id_cols=Peptide, names_from=Run:Channel, values_from=response, names_sep=':') %>% column_to_rownames('Peptide')
  return(dat.tmp)
})

# make vectors with condition labels and color coding corresponding to samples in wide format data
colors.condition <- tribble(
  ~Condition, ~Col,
  "0.125", 'black',
  "0.5", 'blue',
  "0.667", 'green',
  "1", 'red'
)
# sufficient to do that only on the first items of dat.normplot.l and dat.normplot.w lists
colors.condition.map <- dat.normplot.l[[1]] %>% distinct(Run:Channel, Condition) %>% left_join(colors.condition, by='Condition')
ord <- match(colnames(dat.normplot.w[[1]]), colors.condition.map$`Run:Channel`)

# important: these two vectors contain colors and condition labels corresponding to data in wide format
cols.vec <- colors.condition.map[ord, 'Col']  %>% pull
conditions.vec <- colors.condition.map[ord, 'Condition']  %>% pull
```

## Boxplots

```{r}
par(mfrow=c(2,2))
  boxplot.ils(dat.summ.l[[1]], 'Raw')
  
  for (i in 1: n.comp.variants){
    boxplot.ils(dat.norm.l[[i]], paste(variant.names[i], 'normalization', sep=' '))
  }
par(mfrow=c(1,1))
```

## MA plots

MA plots of two single samples taken from condition 1 and condition 0.125, measured in different MS runs (samples *Mixture2_1:127C* and *Mixture1_2:129N*, respectively).

```{r}
# different unit variants require different computation of fold changes and average abundance: additive or multiplicative scale; see maplot.ils function 
scale.vec <- c('log', 'raw', 'log') 

p <- vector('list', n.comp.variants+1)
p[[1]] <- maplot.ils(dat.summplot.w[[1]], 'Mixture2_1:127C', 'Mixture1_2:129N', scale.vec[i], 'Raw')
                     
for (i in 1: n.comp.variants){
  p[[i+1]] <- maplot.ils(dat.normplot.w[[i]], 'Mixture2_1:127C', 'Mixture1_2:129N', scale.vec[i], paste('Normalized', variant.names[i], sep='_'))
}
grid.arrange(grobs = p, ncol=2, nrow=2)
```

MA plots of all samples from condition `1` and condition `0.125` (quantification values averaged within condition).

```{r}
# different unit variants require different computation of fold changes and average abundance: additive or multiplicative scale; see maplot.ils function 
scale.vec <- c('log', 'raw', 'log') 
samples.num <- colors.condition.map %>% filter(Condition=='1') %>% distinct(`Run:Channel`) %>% pull
samples.denom <- colors.condition.map %>% filter(Condition=='0.125') %>% distinct(`Run:Channel`) %>% pull

p <- vector('list', n.comp.variants+1)
p[[1]] <- maplot.ils(dat.summplot.w[[1]], samples.num, samples.denom, scale.vec[i], 'Raw')
                     
for (i in 1: n.comp.variants){
  p[[i+1]] <- maplot.ils(dat.normplot.w[[i]], samples.num, samples.denom, scale.vec[i], paste('Normalized', variant.names[i], sep='_'))
}
grid.arrange(grobs = p, ncol=2, nrow=2)
```

## CV (coefficient of variation) plots

```{r}
par(mfrow=c(2, 2))
  cvplot.ils(dat=dat.summplot.l[[1]], feature.group='Peptide', xaxis.group='Condition', 
               title='Raw')
  
for (i in 1: n.comp.variants){
  cvplot.ils(dat=dat.normplot.l[[i]], feature.group='Peptide', xaxis.group='Condition', 
               title=paste('Normalized', variant.names[i], sep='_'))
}
par(mfrow=c(1, 1))  
```

## PCA plots

### Using all proteins
```{r}
# create a shorter version of run variable to present on legend
run.labels <- stri_replace(unlist(lapply(stri_split(colnames(dat.summplot.w[[1]]), fixed=':'), function(x) x[1])), fixed='Mixture', 'Mix')

par(mfrow=c(2, 2))
  pcaplot.ils(dat.summplot.w[[1]], run.labels, conditions.vec, cols.vec, 'Raw', scale=T)
  
for (i in 1: n.comp.variants){
    pcaplot.ils(dat.normplot.w[[i]], run.labels, conditions.vec, cols.vec, paste('Normalized', variant.names[i], sep='_'))
}
par(mfrow=c(1, 1))
```

### Using spiked proteins only

```{r}
# create a shorter version of run variable to present on legend
spiked.peptides <- dat.l %>% filter(Protein %in% spiked.proteins) %>% distinct(Peptide) %>% pull

par(mfrow=c(2, 2))
  pcaplot.ils(dat.summplot.w[[1]][rownames(dat.summplot.w[[1]]) %in% spiked.peptides, ] , run.labels, conditions.vec, cols.vec, 'Raw', scale=T)
  
for (i in 1: n.comp.variants){
    pcaplot.ils(dat.normplot.w[[i]][rownames(dat.summplot.w[[1]]) %in% spiked.peptides, ], run.labels, conditions.vec, cols.vec, paste('Normalized', variant.names[i], sep='_'))
}
par(mfrow=c(1, 1))
```

### Fitting the LMM models to spiked proteins only

```{r}
dat.norm.l.spk <- emptyList(variant.names)
dat.norm.l.spk <- lapply(dat.norm.l.spk, function(x) x[[1]] <- dat.summ.l[[1]] %>% filter(Protein %in% spiked.proteins))
LMM1 <- lmer(response ~ Mixture + Mixture:TechRepMixture + Mixture:TechRepMixture:Channel + (1|Protein)  + (1|Mixture:TechRepMixture:Peptide), data=dat.summ.l[[1]] %>% filter(Protein %in% spiked.proteins))
dat.norm.l.spk[[1]]$response <- residuals(LMM1)

LMM2 <- lmer(response ~ Mixture + Mixture:TechRepMixture + Mixture:TechRepMixture:Channel + (1|Mixture:TechRepMixture:Protein)  + (1|Peptide), data=dat.summ.l[[1]] %>% filter(Protein %in% spiked.proteins))
dat.norm.l.spk[[2]]$response <- residuals(LMM2)

LMM3 <- lmer(response ~ Mixture + Mixture:TechRepMixture + Mixture:TechRepMixture:Channel + (1|Protein)  + (1|Peptide), data=dat.summ.l[[1]] %>% filter(Protein %in% spiked.proteins))
dat.norm.l.spk[[3]]$response <- residuals(LMM3)

dat.normplot.spk.l <- lapply(dat.norm.l.spk, function(x) aggFunc(x, 'response', 'mean')) 
dat.normplot.spk.w <- lapply(dat.normplot.spk.l, function(x) {
  dat.tmp <- pivot_wider(data=x, id_cols=Peptide, names_from=Run:Channel, values_from=response, names_sep=':') %>% column_to_rownames('Peptide')
  return(dat.tmp)
})

par(mfrow=c(2, 2))
  pcaplot.ils(dat.summplot.w[[1]][rownames(dat.summplot.w[[1]]) %in% spiked.peptides, ] , run.labels, conditions.vec, cols.vec, 'Raw', scale=T)
for (i in 1: n.comp.variants){
    pcaplot.ils(dat.normplot.spk.w[[i]], run.labels, conditions.vec, cols.vec, paste('Normalized', variant.names[i], sep='_'))
}
par(mfrow=c(1, 1))
```

### Fitting the LMM models with weights 

**All proteins included in the models, but only spiked proteins shown on PCA plots**

```{r}
#create weights to increase the importance of the spiked- proteins
# (n1+n2)/n1 for spiked, and (n1+n2)/n2 for background proteins, where n1-# of spiked, n2-# of background
dat.summ.l[[1]] <- dat.summ.l[[1]] %>% mutate(protein.type=ifelse(Protein %in% spiked.proteins, 'spiked', 'background'))
wgts <- dat.summ.l[[1]] %>% group_by(protein.type) %>% summarise(nn=n_distinct(Protein))
n.background <- wgts[wgts$protein.type=='background', 'nn'] %>% pull
n.spiked <- wgts[wgts$protein.type=='spiked', 'nn'] %>% pull
wgt.spiked <- (n.spiked+n.background)/n.spiked
wgt.background <- (n.spiked+n.background)/n.background
dat.summ.l[[1]]$weights <- ifelse(dat.summ.l[[1]]$protein.type=='spiked', wgt.spiked, wgt.background)

dat.norm.l.wgt <- emptyList(variant.names)
dat.norm.l.wgt <- lapply(dat.norm.l, function(x) x[[1]] <- dat.summ.l[[1]])
LMM1 <- lmer(response ~ Mixture + Mixture:TechRepMixture + Mixture:TechRepMixture:Channel + (1|Protein)  + (1|Mixture:TechRepMixture:Peptide), data=dat.summ.l[[1]], weights=weights)
dat.norm.l.wgt[[1]]$response <- residuals(LMM1)
LMM2 <- lmer(response ~ Mixture + Mixture:TechRepMixture + Mixture:TechRepMixture:Channel + (1|Mixture:TechRepMixture:Protein)  + (1|Peptide), data=dat.summ.l[[1]], weights=weights)
dat.norm.l.wgt[[2]]$response <- residuals(LMM2)
LMM3 <- lmer(response ~ Mixture + Mixture:TechRepMixture + Mixture:TechRepMixture:Channel + (1|Protein)  + (1|Peptide), data=dat.summ.l[[1]], weights=weights)
dat.norm.l.wgt[[3]]$response <- residuals(LMM3)

dat.normplot.wgt.l <- lapply(dat.norm.l.wgt, function(x) aggFunc(x, 'response', 'mean')) 
dat.normplot.wgt.w <- lapply(dat.normplot.wgt.l, function(x) {
  dat.tmp <- pivot_wider(data=x, id_cols=Peptide, names_from=Run:Channel, values_from=response, names_sep=':') %>% column_to_rownames('Peptide')
  return(dat.tmp)
})

par(mfrow=c(2, 2))
  pcaplot.ils(dat.summplot.w[[1]][rownames(dat.summplot.w[[1]]) %in% spiked.peptides, ] , run.labels, conditions.vec, cols.vec, 'Raw', scale=T)
  
for (i in 1: n.comp.variants){
    pcaplot.ils(dat.normplot.wgt.w[[i]][rownames(dat.normplot.wgt.w[[1]]) %in% spiked.peptides, ], run.labels, conditions.vec, cols.vec, paste('Normalized', variant.names[i], sep='_'))
}
par(mfrow=c(1, 1))
```

## HC (hierarchical clustering) plots

```{r}
sample.labels <- stri_replace(colnames(dat.summplot.w[[1]]), fixed='Mixture', 'Mix')

par(mfrow=c(2, 2))
dendrogram.ils(dat.summplot.w[[1]], sample.labels, cols.vec, 'Raw')

for (i in 1: n.comp.variants){
  dendrogram.ils(dat.normplot.w[[i]], sample.labels, cols.vec, paste('Normalized', variant.names[i], sep='_'))
}
par(mfrow=c(1, 1))  
```

# DEA component

## mixed model (intra-protein correlation) + eBayes

```{r, cache=TRUE}
dat.dea <- lapply(dat.norm.l, function(x){
  out <- mixed.model.dea(dat=x, mod.formula='response ~ Condition + (1|Run:Channel)', referenceCondition) 
  return(out)
})

# character vectors containing logFC and p-values columns
dea.cols <- colnames(dat.dea[[1]])
logFC.cols <- dea.cols[stri_detect_fixed(dea.cols, 'logFC')]
q.cols <- dea.cols[stri_detect_fixed(dea.cols, 'q.mod')]
n.contrasts <- length(logFC.cols)
```

# Results comparison

## Confusion matrix

```{r, results='asis'}
cm <- conf.mat(dat.dea, 'q.mod', 0.05, spiked.proteins)
print.conf.mat(cm)
```

## Scatter plots

```{r}
scatterplot.ils(dat.dea, q.cols, 'p-values')
scatterplot.ils(dat.dea, logFC.cols, 'log2FC')
```

## Volcano plots

```{r}
for (i in 1:n.contrasts){
  volcanoplot.ils(dat.dea, i, spiked.proteins)
}
```

## Violin plots

Let's see whether the spiked protein fold changes make sense
```{r}
# plot theoretical value (horizontal lines) and violin per condition
dat.spiked.logfc <- lapply(dat.dea, function(x) x[spiked.proteins,logFC.cols])
dat.spiked.logfc.l <- lapply(dat.spiked.logfc, function(x) {
  x %>% rename_with(function(y) sapply(y, function(z) strsplit(z, '_')[[1]][2])) %>% pivot_longer(cols = everything(), names_to = 'condition', values_to = 'logFC') %>% add_column(Protein=rep(rownames(x), each=length(colnames(x)))) })
violinplot.ils(lapply(dat.spiked.logfc.l, filter, condition != referenceCondition))
```

# Conclusions

# Session information

```{r}
sessionInfo()
```









---
title: "Model-based reference notebook"
author: "Piotr Prostko"
date: '`r format(Sys.time(), "%B %d, %Y,%H:%M")`'
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
    theme: flatly
---

```{r, libraries, message=FALSE, echo=FALSE, warning=FALSE}
library(caret)
library(DEP)
library(nlme)
library(lme4)
library(lmerTest)
library(limma)
library(DEP)
library(ggplot2)
library(stringi)
library(RColorBrewer)
library(gridExtra)

library(tidyverse)
```

This is a model-based reference notebook implementing the selected reference methods of each strategy component (i.e., unit, normalization, summarization and DEA). This means that none of the components will be varied throught this analysis. It will just serve as a basis for creating final notebooks.

```{r, echo=FALSE}
source('./other_functions.r')
path.data <- 'G:/My Drive/Isobaric labeling strategies/data'
data.list <- readRDS(paste0(path.data, '/input_data.rds'))
dat.l <- data.list$dat.l
```

First we apply some common filtering steps on the data. This includes removind PSMs with isolation iterference greater or equal than or missing quantification values [Piotr: explain why]. Note that we will not remove proteins called 'one-hit wonders' in proteomic slang and we will not remove shared peptides (yet, this step will be executed prior to DEA).

```{r}
dat.l <- dat.l %>% filter(isoInterOk=='Y' & noNAs=='Y')

# which proteins were spiked in?
spiked.proteins <- dat.l %>% distinct(Protein) %>% filter(stri_detect(Protein, fixed='ups')) %>% pull

# which peptides were identified in each MS run?
unique.pep=dat.l %>% 
  group_by(Run) %>%
  distinct(Peptide) %>% 
  mutate(val=1)
unique.pep <- xtabs(val~Peptide+Run, data=unique.pep)
tmp <- apply(unique.pep, 1, function(x) all(x==1))
inner.peptides <- rownames(unique.pep)[tmp]
```

## Unit

$log2$ transformation of reporter ion intensities.

```{r}
dat.l <- dat.l %>% mutate(log2Intensity=log2(Intensity))
```

`Put here Unit component specific graphs/tables (if applicable)`

## Summarization

No summarization, so the downstream analysis will be conducted on PSM level data.

`Put here Summarization component specific graphs/tables (if applicable)`

```{r, echo=FALSE}
# no summarization needed therefore copty dat.l data set
dat.l.summ <- dat.l
```

## Normalization

```{r, echo=FALSE}
# mod0=lmer(log2Intensity ~ Run + Run:Channel +
#                  (1|Protein)  , data=dat.l.summ)

# mod1=lmer(log2Intensity ~ Run + Run:Channel +
#                  (1|Protein)  + (1|Peptide), data=dat.l.summ)

# mod2=lmer(log2Intensity ~ Run + Run:Channel +
#                  (1|Protein)  + (0+Run|Peptide), data=dat.l.summ)

# mod3=lmer(log2Intensity ~ Run + Run:Channel +
#                   (1|Protein)  + (1|Run:Peptide), data=dat.l.summ)

#saveRDS(list(mod0=mod0, mod1=mod1), paste0(path.data, '/model_objects/model_norm.rds'))
#saveRDS(list(mod0=mod0, mod1=mod1, mod2=mod2, mod3=mod3), paste0(path.data, '/model_objects/model_norm.rds'))
dat.l.norm <- dat.l.summ

model_norm <- readRDS(paste0(path.data, '/model_objects/model_norm.rds'))
mod0 <- model_norm[[1]]
mod1 <- model_norm[[1]]
# mod2 <- model_norm[[2]]
# mod3 <- model_norm[[3]]

dat.l.norm$resid0 <- residuals(mod0)
dat.l.norm$resid1 <- residuals(mod1)
# dat.l.norm$resid2 <- residuals(mod2)
# dat.l.norm$resid3 <- residuals(mod3)
```

`Put here Normalization component specific graphs/tables (if applicable)`

`Show estimated variance components. Show plots of estimated Run and Channel effects.`

`Try to show plots before and after normalization (multiple normalization methods) in one panel`

```{r}
# PSM data needs to be aggregated prior to PCA plots and HC plots (they requires features in the intersection of all MS runs - this is not possible for PSM data). In order to be consisent, other normalization plots will be based on the aggregated data
var.names=c('log2Intensity', paste('resid',0:1,sep=''))
dat.l.normplot=aggFunc(dat.l.norm, var.names, 'mean')

# now create a list for storing normalized data in wide format (response variables e.g. log2Intensity, resid0, resid1 etc. will be located in separate data sets)
dat.w.normplot <- vector('list', length(var.names))
names(dat.w.normplot) <- var.names
for (i in seq_along(var.names)){
  ff <- formula(paste0(var.names[i], '~ Peptide + I(Run:Channel)'))
  dat.w.normplot[[i]] <- xtabs(ff, data=dat.l.normplot, drop.unused.levels = TRUE)
}

# make vectors with condition labels and color coding corresponding to samples in wide format data
colors.condition <- tribble(
  ~Condition, ~Col,
  "0.125", 'black',
  "0.5", 'blue',
  "0.667", 'green',
  "1", 'red'
)
colors.condition.map <- dat.l.norm %>% distinct(Run:Channel, Condition) %>% left_join(colors.condition, by='Condition')
ord <- match(colnames(dat.w.normplot[['log2Intensity']]), colors.condition.map$`Run:Channel`)

# important: these two vectors contain colors and condition labels corresponding to data in wide format
cols.vec <- colors.condition.map[ord, 'Col']  %>% pull
conditions.vec <- colors.condition.map[ord, 'Condition']  %>% pull
```

Boxplots:
```{r}
par(mfrow=c(1,2))
  boxplot(log2Intensity~Run:Channel, dat.l.normplot, main='Before normalization')
  boxplot(resid1~Run:Channel, dat.l.normplot, main='After normalization')
par(mfrow=c(1,1))
```

MA plots:
```{r}
# compute average of all samples in each condition or select just two samples?)
temp <- unclass(dat.w.normplot[['log2Intensity']][, c('Mixture1_1:128C', 'Mixture1_1:129C') ])
FC <- temp[,1]-temp[,2]
AVE <- .5*(temp[,1]+temp[,2])
df=data.frame(FC, AVE)
p1 <- ggplot(df, aes(x = AVE, y = FC)) +
  geom_point() +
  geom_smooth() +
  scale_y_continuous("log2FC") +
  scale_x_continuous("logAvg_intensity") +
  ggtitle("Before normalization") + 
  geom_hline(yintercept = 0.0, color = "black") + # one-to-one line
  geom_hline(yintercept = 1.0, color = "black", linetype = "dotted") + # 2-fold up
  geom_hline(yintercept = -1.0, color = "black", linetype = "dotted") # 2-fold down

temp <- unclass(dat.w.normplot[['resid1']][, c('Mixture1_1:128C', 'Mixture1_1:129C') ])
FC <- temp[,1]-temp[,2]
AVE <- .5*(temp[,1]+temp[,2])
df=data.frame(FC, AVE)
p2 <- ggplot(df, aes(x = AVE, y = FC)) +
  geom_point() +
  geom_smooth() +
  scale_y_continuous("log2FC") +
  scale_x_continuous("logAvg_intensity") +
  ggtitle("After normalization") + 
  geom_hline(yintercept = 0.0, color = "black") + # one-to-one line
  geom_hline(yintercept = 1.0, color = "black", linetype = "dotted") + # 2-fold up
  geom_hline(yintercept = -1.0, color = "black", linetype = "dotted") # 2-fold down
grid.arrange(p1, p2, ncol=2)
```

CV (coefficient of variation plots):
```{r}

```

PCA plots:
```{r}
par(mfrow=c(1,2))
  plotMDS(dat.w.normplot[['log2Intensity']], col=cols.vec, main='Before normalization')
  plotMDS(dat.w.normplot[['resid1']], col=cols.vec, main='After normalization')
par(mfrow=c(2,2))
```

HC plots:
```{r}
par(mfrow=c(1,2))
heatmap(dat.w.normplot[['log2Intensity']], hclustfun = function(d) hclust(d, method = "average"),col=brewer.pal(11,"RdBu"),
          scale='none',labRow = '', ColSideColors=cols.vec, main='Before normalization')

heatmap(dat.w.normplot[['resid1']], hclustfun = function(d) hclust(d, method = "average"),col=brewer.pal(11,"RdBu"),
          scale='none',labRow = '', ColSideColors=cols.vec, main='After normalization')
par(mfrow=c(1,1))
```

## DEA
```{r, warning=FALSE, message=FALSE}
# remove shared peptides before DEA
shared.peptides <- dat.l %>% filter(shared.peptide=='Y') %>% 
  distinct(Peptide) %>% pull
dat.l.norm <- dat.l.norm %>% filter(!(Peptide %in% shared.peptides))

dea1 <- mixed.model.dea(dat=dat.l.norm, mod.formula='resid1 ~ Condition + (1|Run:Channel)', conditions=c('1', '0.125'))
head(dea1)

# distribution of raw p-values
ggplot(dea1, aes(p.ord)) + 
  geom_histogram(bins = 100, fill = "white", color = "black") + 
  ggtitle("LMM norm and DEA p-value distribution")

# of Up/Down/Not regulated proteins
regulated.proteins(dea.mat=dea1, score.var='p.mod', conditions=c('1', '0.125'), cut.off=.05)

# confusion matrix
conf.mat(dea.mat=dea1, score.var='p.mod', cut.off=.05)

# volcano plot
ggplot(dea1, aes(x = logFC, y = -log10(q.mod))) +
  geom_point(aes(color = candidate, shape = candidate)) +
  xlab("log2(FC)") +
  ylab("-log10(FDR)") +
  ggtitle("LMM norm and DEA") +
  geom_hline(yintercept = -log10(0.05), color = "black", linetype = "dashed") + 
  geom_vline(xintercept =  1, color = "black", linetype = "dashed") +
  geom_vline(xintercept = -1, color = "black", linetype = "dashed") 

# top table

# bar plot of Top 4 proteins

```

## Conclusions 

## Log the session information
```{r}
sessionInfo()
```



